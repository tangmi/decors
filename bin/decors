#!/usr/bin/env node

/*
	CLI stuffs
*/
var program = require('commander'),
	package = require('../package.json'),
	path = require('path'),
	colors = require('colors');

program.version(package.version);
program.option('-w, --watch', 'reload app and inject css on file save');
program.option('-b, --backend <baseurl>', 'have decors make backend requests to eliminate CORS issues')
program.option('-p, --port <port>', 'set a custom port (default 9000)')
program.parse(process.argv);

var appdir = path.resolve(program.args.shift() || '.');

console.log();
console.log(' decors' + ('@' + package.version).grey);
console.log();

/*
	server stuffs
*/
var express = require('express'),
	tinylr = require('tiny-lr'),
	livereload = require('connect-livereload'),
	http = require('http'),
	https = require('https'),
	fs = require('fs'),
	chokidar = require('chokidar'),
	stream = require('stream'),
	url = require('url'),
	mime = require('mime');

var app = express();

app.set('port', program.port || 9000);

// watch file tree for changes and use the livereload middleware to update the client
var liveReloadPort = 35729;
if (program.watch) {
	//add in the middleware
	app.use(require('connect-livereload')({
		port: liveReloadPort
	}));

	//start up livereload server
	var server = tinylr();
	server.listen(liveReloadPort, function(err) {
		if (err) {
			console.log(err);
			return;
		}
		console.log('Watching for changes:', appdir);
	});

	//set up file watchers
	var watcher = chokidar.watch(appdir, {
		// ignored: /.*((?:\.css)|(?:\.js(on)?))$/, //matches .css, .js, .json
		persistent: true,
		ignoreInitial: true,
		interval: 500,
		binaryInterval: 3000,
	});

	watcher
		.on('add', reload)
		.on('change', reload)
		.on('unlink', reload)
		.on('error', function(error) {
			console.log(error);
		});

	function reload(file) {
		var files = [];
		files.push(file);

		server.changed({
			body: {
				files: files
			}
		});
	};

}

// reroute backend API calls to a separate backend server, avoiding all CORS issues on the client side
if (program.backend) {

	//add some middleware to save the raw body
	app.use(function(req, res, next) {
		req.setEncoding('utf8');
		req.rawBody = '';
		req.on('data', function(chunk) {
			req.rawBody += chunk;
		});
		req.on('end', function() {
			next();
		});
	});

	console.log('Rerouting API calls to:', program.backend)
	app.use(function(req, res, next) {

		//for the empty directory index.html edge case
		var indexExists = fs.existsSync(path.join(appdir, req.path, 'index.html'));
		if(req.path.lastIndexOf('/') == req.path.length - 1 && indexExists) {
			next();
		} else if (fs.existsSync(path.join(appdir, req.path)) && indexExists) {
			next();
		} else {
			if (program.backend.lastIndexOf('/') === program.backend.length - 1) {
				program.backend.substring(0, program.backend.length - 2);
			}
			if (req.path.indexOf('/') !== 0) {
				req.path = '/' + req.path;
			}

			// if (req.path.indexOf('favicon.ico') === 1) {
			// 	return;
			// }

			var remotepath = program.backend + req.path;
			if (remotepath.indexOf('http') !== 0) {
				remotepath = 'http://' + remotepath;
			}

			var querystring = url.parse(req.url).query;
			if(typeof querystring !== 'undefined' && querystring != null) {
				remotepath += '?' + querystring;
			}

			var regex = new RegExp('^([a-zA-Z]+)://([^/]+)(?:\:([0-9]+))(/.*)?$');
			var protocol = remotepath.indexOf('https') === 0 ? https : http;

			var reqoptions = {
				host: remotepath.replace(regex, '$2'),
				port: remotepath.replace(regex, '$3'),
				path: remotepath.replace(regex, '$4'),
				method: req.method,
				headers: req.headers
			};

			if (app.get('port') == reqoptions.port) {
				res.end(404);
			}

			var remoterequest = protocol.request(reqoptions, function(data) {
				var output = '';

				var useutf8 = /text\/.+/.test(mime.lookup(req.path)); //determines the data transfer encoding

				if (useutf8) {
					data.setEncoding('utf8');
				} else {
					data.setEncoding('binary');
				}

				data.on('data', function(chunk) {
					output += chunk;
				});

				data.on('end', function() {
					res.statusCode = data.statusCode;
					res.headers = data.headers;
					res.setHeader('Content-Type', data.headers['content-type']);
					res.setHeader('Content-Length', output.length);
					if (useutf8) {
						res.send(output);
					} else {
						res.write(output, encoding = 'binary');
						res.end();
					}

					console.log((req.method + '').green, (res.statusCode + '').magenta, 'remote'.yellow, remotepath);
				});
			});

			remoterequest.write(req.rawBody);

			remoterequest.on('error', function(e) {
				res.contentType('text/plain');
				res.send(404);
				console.log((req.method + '').green, '404'.red, 'remote'.yellow, remotepath, ('(' + e.message + ')').grey);
			});

			remoterequest.end();
		}
	});
}

// use the connect static middleware
app.use(function(req, res, next) {
	var actualpath = req.path;
	if (req.path.lastIndexOf('/') === req.path.length - 1) {
		actualpath += 'index.html';
	}
	console.log((req.method + '').green, (res.statusCode + '').magenta, 'local'.cyan, actualpath);
	express.static(appdir)(req, res, next);
});

/*
	begin the actual server
*/
http.createServer(app).listen(app.get('port'), function() {
	console.log('Decors server started on port', app.get('port'));
	// console.log('Serving:', appdir);
	console.log();
});